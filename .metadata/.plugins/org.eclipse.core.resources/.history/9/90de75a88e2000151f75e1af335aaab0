/**
 * 项目  dzah-biz 
 * 创建时间  2015-7-2 上午10:24:14 
 * Copyright (c) 2015, wchhuangya All rights reserved.
 * wchhuangya 专有/保密源代码,未经许可禁止任何人通过任何* 渠道使用、修改源代码.
 */

package com.ch.wchhuangya.dzah.biz.common;

import java.io.Serializable;
import java.lang.reflect.Field;
import java.lang.reflect.ParameterizedType;
import java.util.HashMap;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.orm.hibernate4.support.HibernateDaoSupport;
import org.springframework.util.Assert;


/**
 * 类名: AbstractDao <br/> 
 * 功能: 数据访问层的基类 <br/> 负责为单个Entity对象提供CRUD操作的Hibernate DAO基类 <br/>
 * 子类只要在类定义时指定所管理Entity的Class, 即拥有对单个Entity对象的CRUD操作.
 * 创建日期: 2015-7-2 上午10:24:14 <br/> 
 *
 * @author wchya
 * @since Jdk 1.6
 * @see       
 *
 */
@SuppressWarnings("unchecked")
public class AbstractDao<T, PK extends Serializable> extends HibernateDaoSupport {

	@Autowired
	protected JdbcTemplate jdbcTemplate;
	
	public JdbcTemplate getJdbcTemplate(){
		return jdbcTemplate;
	}
	
	/** Dao所管理的Entity类型 */
	protected Class<T> entityClass;

    /** 本类对应实体的字段与类型映射 */
    private Map<String, String> fieldClassNames = null;

    /**
     * 取得entityClass. JDK1.4不支持泛型的子类可以抛开Class<T> entityClass,重载此函数达到相同效果。
     */
    protected Class<T> getEntityClass() {
    	return entityClass;
    }

    /**
     * 初始化属性名称与类型名称的键值对映射
     */
    private void initEntityFieldsClassNames() {
		Field[] fields = this.entityClass.getDeclaredFields();
		this.fieldClassNames = new HashMap<String, String>();
		for (Field field : fields) {
		    fieldClassNames.put(field.getName(), field.getType().getName());
		}
    }
	
	public AbstractDao(){
		// 通过范型反射，取得在子类中定义的entityClass.
		this.entityClass = (Class<T>) ((ParameterizedType) getClass()
			.getGenericSuperclass()).getActualTypeArguments()[0];
			this.initEntityFieldsClassNames();
	}

    public Serializable save(T entity) throws DataAccessException {
		Assert.notNull(entity, "entity不能为空");
		return getHibernateTemplate().save(entity);
    }

    public void saveOrUpdate(T entity) throws DataAccessException {
		Assert.notNull(entity, "entity不能为空");
		getHibernateTemplate().saveOrUpdate(entity);
    }

    public T merge(T entity) throws DataAccessException {
		Assert.notNull(entity, "entity不能为空");
		return (T) getHibernateTemplate().merge(entity);
    }

    public T update(T entity) throws DataAccessException {
		Assert.notNull(entity, "entity不能为空");
		return (T) getHibernateTemplate().merge(entity);
    }

    public void delete(T entity) throws DataAccessException {
		Assert.notNull(entity, "entity不能为空");
		getHibernateTemplate().delete(entity);
    }

    public void delete(final PK id) throws DataAccessException {
		Assert.notNull(id, "id不能为空");
		getHibernateTemplate().delete(get(id));
    }

    public void deleteAll(List<T> entities) throws DataAccessException {
		Assert.notNull(entities, "entities不能为空");
		getHibernateTemplate().deleteAll(entities);
    }
}
